/* tslint:disable */
/* eslint-disable */
/**
 * AKW Application API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    DUMMY_BASE_URL,
    assertParamExists,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    serializeDataIfNeeded,
    toPathString,
    createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
    BASE_PATH,
    COLLECTION_FORMATS,
    BaseAPI,
    RequiredError,
    operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface Admin
 */
export interface Admin {
    /**
     *
     * @type {string}
     * @memberof Admin
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof Admin
     */
    _id: string;
    /**
     *
     * @type {string}
     * @memberof Admin
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof Admin
     */
    updatedAt: string;
    /**
     *
     * @type {string}
     * @memberof Admin
     */
    email: string;
}
/**
 *
 * @export
 * @interface BaseModel
 */
export interface BaseModel {
    /**
     *
     * @type {string}
     * @memberof BaseModel
     */
    _id: string;
    /**
     *
     * @type {string}
     * @memberof BaseModel
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof BaseModel
     */
    updatedAt: string;
}
/**
 *
 * @export
 * @interface BaseUser
 */
export interface BaseUser {
    /**
     *
     * @type {string}
     * @memberof BaseUser
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof BaseUser
     */
    _id: string;
    /**
     *
     * @type {string}
     * @memberof BaseUser
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof BaseUser
     */
    updatedAt: string;
}
/**
 *
 * @export
 * @interface KycSubmission
 */
export interface KycSubmission {
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    firstName: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    lastName: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    phoneNumber: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    gender: KycSubmissionGenderEnum;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    userId: string;
    /**
     *
     * @type {User}
     * @memberof KycSubmission
     */
    user?: User;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    status: KycSubmissionStatusEnum;
    /**
     *
     * @type {Array<UserDocument>}
     * @memberof KycSubmission
     */
    documents: Array<UserDocument>;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    _id: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof KycSubmission
     */
    updatedAt: string;
}

export const KycSubmissionGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
} as const;

export type KycSubmissionGenderEnum =
    (typeof KycSubmissionGenderEnum)[keyof typeof KycSubmissionGenderEnum];
export const KycSubmissionStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
} as const;

export type KycSubmissionStatusEnum =
    (typeof KycSubmissionStatusEnum)[keyof typeof KycSubmissionStatusEnum];

/**
 *
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     *
     * @type {string}
     * @memberof LoginDto
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof LoginDto
     */
    password: string;
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    accessToken: string;
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    refreshToken: string;
}
/**
 *
 * @export
 * @interface PaginatedKycSubmissionResponse
 */
export interface PaginatedKycSubmissionResponse {
    /**
     *
     * @type {Array<KycSubmission>}
     * @memberof PaginatedKycSubmissionResponse
     */
    docs: Array<KycSubmission>;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    limit: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    page?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    totalDocs: number;
    /**
     *
     * @type {boolean}
     * @memberof PaginatedKycSubmissionResponse
     */
    hasPrevPage: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PaginatedKycSubmissionResponse
     */
    hasNextPage: boolean;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    totalPages: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    offset: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    prevPage?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    nextPage?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedKycSubmissionResponse
     */
    pagingCounter: number;
}
/**
 *
 * @export
 * @interface PaginatedResponse
 */
export interface PaginatedResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    limit: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    page?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    totalDocs: number;
    /**
     *
     * @type {boolean}
     * @memberof PaginatedResponse
     */
    hasPrevPage: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PaginatedResponse
     */
    hasNextPage: boolean;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    totalPages: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    offset: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    prevPage?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    nextPage?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponse
     */
    pagingCounter: number;
}
/**
 *
 * @export
 * @interface PaginatedUserResponse
 */
export interface PaginatedUserResponse {
    /**
     *
     * @type {Array<User>}
     * @memberof PaginatedUserResponse
     */
    docs: Array<User>;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    limit: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    page?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    totalDocs: number;
    /**
     *
     * @type {boolean}
     * @memberof PaginatedUserResponse
     */
    hasPrevPage: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PaginatedUserResponse
     */
    hasNextPage: boolean;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    totalPages: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    offset: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    prevPage?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    nextPage?: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedUserResponse
     */
    pagingCounter: number;
}
/**
 *
 * @export
 * @interface PaginationQueryParams
 */
export interface PaginationQueryParams {
    /**
     *
     * @type {number}
     * @memberof PaginationQueryParams
     */
    page?: number;
    /**
     *
     * @type {number}
     * @memberof PaginationQueryParams
     */
    limit?: number;
}
/**
 *
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    accessToken: string;
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    refreshToken: string;
}
/**
 *
 * @export
 * @interface TotalKycSubmissionResponse
 */
export interface TotalKycSubmissionResponse {
    /**
     *
     * @type {number}
     * @memberof TotalKycSubmissionResponse
     */
    count: number;
}
/**
 *
 * @export
 * @interface TotalUserCountResponse
 */
export interface TotalUserCountResponse {
    /**
     *
     * @type {number}
     * @memberof TotalUserCountResponse
     */
    count: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    firstName: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    lastName: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    kycStatus?: UserKycStatusEnum;
    /**
     *
     * @type {string}
     * @memberof User
     */
    _id: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    updatedAt: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    email: string;
}

export const UserKycStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
} as const;

export type UserKycStatusEnum =
    (typeof UserKycStatusEnum)[keyof typeof UserKycStatusEnum];

/**
 *
 * @export
 * @interface UserDocument
 */
export interface UserDocument {
    /**
     *
     * @type {string}
     * @memberof UserDocument
     */
    url: string;
    /**
     *
     * @type {string}
     * @memberof UserDocument
     */
    mimetype: string;
    /**
     *
     * @type {number}
     * @memberof UserDocument
     */
    size: number;
}
/**
 *
 * @export
 * @interface UserRegisterDto
 */
export interface UserRegisterDto {
    /**
     *
     * @type {string}
     * @memberof UserRegisterDto
     */
    firstName: string;
    /**
     *
     * @type {string}
     * @memberof UserRegisterDto
     */
    lastName: string;
    /**
     *
     * @type {string}
     * @memberof UserRegisterDto
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof UserRegisterDto
     */
    password: string;
}
/**
 *
 * @export
 * @interface UserRegisterResponse
 */
export interface UserRegisterResponse {
    /**
     *
     * @type {string}
     * @memberof UserRegisterResponse
     */
    accessToken: string;
    /**
     *
     * @type {string}
     * @memberof UserRegisterResponse
     */
    refreshToken: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
    configuration?: Configuration,
) {
    return {
        /**
         *
         * @summary Admin login
         * @param {LoginDto} [loginDto] LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAdminLogin: async (
            loginDto?: LoginDto,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/admin/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                loginDto,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Admin profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAdminProfile: async (
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/admin/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Admin refresh token
         * @param {string} [refreshToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAdminRefreshToken: async (
            refreshToken?: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/admin/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (refreshToken != null) {
                localVarHeaderParameter['refresh-token'] = String(refreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary User login
         * @param {LoginDto} [loginDto] LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserLogin: async (
            loginDto?: LoginDto,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                loginDto,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary User profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserProfile: async (
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary User refresh token
         * @param {string} [refreshToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserRefreshToken: async (
            refreshToken?: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (refreshToken != null) {
                localVarHeaderParameter['refresh-token'] = String(refreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary User register
         * @param {UserRegisterDto} [userRegisterDto] UserRegisterDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserRegister: async (
            userRegisterDto?: UserRegisterDto,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                userRegisterDto,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Admin login
         * @param {LoginDto} [loginDto] LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerAdminLogin(
            loginDto?: LoginDto,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<LoginResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerAdminLogin(
                    loginDto,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerAdminLogin']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Admin profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerAdminProfile(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerAdminProfile(
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerAdminProfile']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Admin refresh token
         * @param {string} [refreshToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerAdminRefreshToken(
            refreshToken?: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<RefreshTokenResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerAdminRefreshToken(
                    refreshToken,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerAdminRefreshToken']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary User login
         * @param {LoginDto} [loginDto] LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUserLogin(
            loginDto?: LoginDto,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<LoginResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerUserLogin(
                    loginDto,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerUserLogin']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary User profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUserProfile(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerUserProfile(
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerUserProfile']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary User refresh token
         * @param {string} [refreshToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUserRefreshToken(
            refreshToken?: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<RefreshTokenResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerUserRefreshToken(
                    refreshToken,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerUserRefreshToken']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary User register
         * @param {UserRegisterDto} [userRegisterDto] UserRegisterDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUserRegister(
            userRegisterDto?: UserRegisterDto,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<UserRegisterResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.authControllerUserRegister(
                    userRegisterDto,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.authControllerUserRegister']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         *
         * @summary Admin login
         * @param {LoginDto} [loginDto] LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAdminLogin(
            loginDto?: LoginDto,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<LoginResponse> {
            return localVarFp
                .authControllerAdminLogin(loginDto, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Admin profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAdminProfile(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Admin> {
            return localVarFp
                .authControllerAdminProfile(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Admin refresh token
         * @param {string} [refreshToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAdminRefreshToken(
            refreshToken?: string,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RefreshTokenResponse> {
            return localVarFp
                .authControllerAdminRefreshToken(refreshToken, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary User login
         * @param {LoginDto} [loginDto] LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserLogin(
            loginDto?: LoginDto,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<LoginResponse> {
            return localVarFp
                .authControllerUserLogin(loginDto, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary User profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserProfile(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<User> {
            return localVarFp
                .authControllerUserProfile(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary User refresh token
         * @param {string} [refreshToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserRefreshToken(
            refreshToken?: string,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RefreshTokenResponse> {
            return localVarFp
                .authControllerUserRefreshToken(refreshToken, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary User register
         * @param {UserRegisterDto} [userRegisterDto] UserRegisterDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserRegister(
            userRegisterDto?: UserRegisterDto,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<UserRegisterResponse> {
            return localVarFp
                .authControllerUserRegister(userRegisterDto, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @summary Admin login
     * @param {LoginDto} [loginDto] LoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerAdminLogin(
        loginDto?: LoginDto,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .authControllerAdminLogin(loginDto, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Admin profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerAdminProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .authControllerAdminProfile(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Admin refresh token
     * @param {string} [refreshToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerAdminRefreshToken(
        refreshToken?: string,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .authControllerAdminRefreshToken(refreshToken, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary User login
     * @param {LoginDto} [loginDto] LoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUserLogin(
        loginDto?: LoginDto,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .authControllerUserLogin(loginDto, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary User profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUserProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .authControllerUserProfile(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary User refresh token
     * @param {string} [refreshToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUserRefreshToken(
        refreshToken?: string,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .authControllerUserRefreshToken(refreshToken, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary User register
     * @param {UserRegisterDto} [userRegisterDto] UserRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUserRegister(
        userRegisterDto?: UserRegisterDto,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .authControllerUserRegister(userRegisterDto, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
    configuration?: Configuration,
) {
    return {
        /**
         *
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealthCheck: async (
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerHealthCheck(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.healthControllerHealthCheck(
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['HealthApi.healthControllerHealthCheck']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = HealthApiFp(configuration);
    return {
        /**
         *
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealthCheck(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .healthControllerHealthCheck(options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     *
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerHealthCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration)
            .healthControllerHealthCheck(options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * KycSubmissionApi - axios parameter creator
 * @export
 */
export const KycSubmissionApiAxiosParamCreator = function (
    configuration?: Configuration,
) {
    return {
        /**
         *
         * @summary Approve submission
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerApproveSubmission: async (
            id: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerApproveSubmission',
                'id',
                id,
            );
            const localVarPath = `/kyc-submissions/{id}/approve`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create kyc submission
         * @param {string} firstName
         * @param {string} lastName
         * @param {string} email
         * @param {string} address
         * @param {string} phoneNumber
         * @param {KycSubmissionControllerCreateKycSubmissionGenderEnum} gender
         * @param {Array<File>} documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerCreateKycSubmission: async (
            firstName: string,
            lastName: string,
            email: string,
            address: string,
            phoneNumber: string,
            gender: KycSubmissionControllerCreateKycSubmissionGenderEnum,
            documents: Array<File>,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'firstName',
                firstName,
            );
            // verify required parameter 'lastName' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'lastName',
                lastName,
            );
            // verify required parameter 'email' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'email',
                email,
            );
            // verify required parameter 'address' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'address',
                address,
            );
            // verify required parameter 'phoneNumber' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'phoneNumber',
                phoneNumber,
            );
            // verify required parameter 'gender' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'gender',
                gender,
            );
            // verify required parameter 'documents' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerCreateKycSubmission',
                'documents',
                documents,
            );
            const localVarPath = `/kyc-submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration &&
                configuration.formDataCtor) ||
                FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (firstName !== undefined) {
                localVarFormParams.append('firstName', firstName as any);
            }

            if (lastName !== undefined) {
                localVarFormParams.append('lastName', lastName as any);
            }

            if (email !== undefined) {
                localVarFormParams.append('email', email as any);
            }

            if (address !== undefined) {
                localVarFormParams.append('address', address as any);
            }

            if (phoneNumber !== undefined) {
                localVarFormParams.append('phoneNumber', phoneNumber as any);
            }

            if (gender !== undefined) {
                localVarFormParams.append('gender', gender as any);
            }
            if (documents) {
                localVarFormParams.append(
                    'documents',
                    new Blob([JSON.stringify(documents)], {
                        type: 'image/png, image/jpeg, image/jpg',
                    }),
                );
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Kyc submission by user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerKycSubmissionByUser: async (
            userId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerKycSubmissionByUser',
                'userId',
                userId,
            );
            const localVarPath = `/kyc-submissions/user/{userId}`.replace(
                `{${'userId'}}`,
                encodeURIComponent(String(userId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Kyc submission count
         * @param {string} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerKycSubmissionCount: async (
            status?: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/kyc-submissions/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Paginated kyc submissions
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerPaginatedKycSubmissions: async (
            page?: number,
            limit?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/kyc-submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reject submission
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerRejectSubmission: async (
            id: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists(
                'kycSubmissionControllerRejectSubmission',
                'id',
                id,
            );
            const localVarPath = `/kyc-submissions/{id}/reject`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * KycSubmissionApi - functional programming interface
 * @export
 */
export const KycSubmissionApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator =
        KycSubmissionApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Approve submission
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycSubmissionControllerApproveSubmission(
            id: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<KycSubmission>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.kycSubmissionControllerApproveSubmission(
                    id,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'KycSubmissionApi.kycSubmissionControllerApproveSubmission'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create kyc submission
         * @param {string} firstName
         * @param {string} lastName
         * @param {string} email
         * @param {string} address
         * @param {string} phoneNumber
         * @param {KycSubmissionControllerCreateKycSubmissionGenderEnum} gender
         * @param {Array<File>} documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycSubmissionControllerCreateKycSubmission(
            firstName: string,
            lastName: string,
            email: string,
            address: string,
            phoneNumber: string,
            gender: KycSubmissionControllerCreateKycSubmissionGenderEnum,
            documents: Array<File>,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<KycSubmission>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.kycSubmissionControllerCreateKycSubmission(
                    firstName,
                    lastName,
                    email,
                    address,
                    phoneNumber,
                    gender,
                    documents,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'KycSubmissionApi.kycSubmissionControllerCreateKycSubmission'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Kyc submission by user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycSubmissionControllerKycSubmissionByUser(
            userId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<KycSubmission>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.kycSubmissionControllerKycSubmissionByUser(
                    userId,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'KycSubmissionApi.kycSubmissionControllerKycSubmissionByUser'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Kyc submission count
         * @param {string} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycSubmissionControllerKycSubmissionCount(
            status?: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<TotalKycSubmissionResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.kycSubmissionControllerKycSubmissionCount(
                    status,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'KycSubmissionApi.kycSubmissionControllerKycSubmissionCount'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Paginated kyc submissions
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycSubmissionControllerPaginatedKycSubmissions(
            page?: number,
            limit?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<PaginatedKycSubmissionResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.kycSubmissionControllerPaginatedKycSubmissions(
                    page,
                    limit,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'KycSubmissionApi.kycSubmissionControllerPaginatedKycSubmissions'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Reject submission
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycSubmissionControllerRejectSubmission(
            id: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<KycSubmission>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.kycSubmissionControllerRejectSubmission(
                    id,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'KycSubmissionApi.kycSubmissionControllerRejectSubmission'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * KycSubmissionApi - factory interface
 * @export
 */
export const KycSubmissionApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = KycSubmissionApiFp(configuration);
    return {
        /**
         *
         * @summary Approve submission
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerApproveSubmission(
            id: string,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<KycSubmission> {
            return localVarFp
                .kycSubmissionControllerApproveSubmission(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create kyc submission
         * @param {string} firstName
         * @param {string} lastName
         * @param {string} email
         * @param {string} address
         * @param {string} phoneNumber
         * @param {KycSubmissionControllerCreateKycSubmissionGenderEnum} gender
         * @param {Array<File>} documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerCreateKycSubmission(
            firstName: string,
            lastName: string,
            email: string,
            address: string,
            phoneNumber: string,
            gender: KycSubmissionControllerCreateKycSubmissionGenderEnum,
            documents: Array<File>,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<KycSubmission> {
            return localVarFp
                .kycSubmissionControllerCreateKycSubmission(
                    firstName,
                    lastName,
                    email,
                    address,
                    phoneNumber,
                    gender,
                    documents,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Kyc submission by user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerKycSubmissionByUser(
            userId: string,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<KycSubmission> {
            return localVarFp
                .kycSubmissionControllerKycSubmissionByUser(userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Kyc submission count
         * @param {string} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerKycSubmissionCount(
            status?: string,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<TotalKycSubmissionResponse> {
            return localVarFp
                .kycSubmissionControllerKycSubmissionCount(status, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Paginated kyc submissions
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerPaginatedKycSubmissions(
            page?: number,
            limit?: number,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedKycSubmissionResponse> {
            return localVarFp
                .kycSubmissionControllerPaginatedKycSubmissions(
                    page,
                    limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reject submission
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycSubmissionControllerRejectSubmission(
            id: string,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<KycSubmission> {
            return localVarFp
                .kycSubmissionControllerRejectSubmission(id, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * KycSubmissionApi - object-oriented interface
 * @export
 * @class KycSubmissionApi
 * @extends {BaseAPI}
 */
export class KycSubmissionApi extends BaseAPI {
    /**
     *
     * @summary Approve submission
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycSubmissionApi
     */
    public kycSubmissionControllerApproveSubmission(
        id: string,
        options?: RawAxiosRequestConfig,
    ) {
        return KycSubmissionApiFp(this.configuration)
            .kycSubmissionControllerApproveSubmission(id, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create kyc submission
     * @param {string} firstName
     * @param {string} lastName
     * @param {string} email
     * @param {string} address
     * @param {string} phoneNumber
     * @param {KycSubmissionControllerCreateKycSubmissionGenderEnum} gender
     * @param {Array<File>} documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycSubmissionApi
     */
    public kycSubmissionControllerCreateKycSubmission(
        firstName: string,
        lastName: string,
        email: string,
        address: string,
        phoneNumber: string,
        gender: KycSubmissionControllerCreateKycSubmissionGenderEnum,
        documents: Array<File>,
        options?: RawAxiosRequestConfig,
    ) {
        return KycSubmissionApiFp(this.configuration)
            .kycSubmissionControllerCreateKycSubmission(
                firstName,
                lastName,
                email,
                address,
                phoneNumber,
                gender,
                documents,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Kyc submission by user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycSubmissionApi
     */
    public kycSubmissionControllerKycSubmissionByUser(
        userId: string,
        options?: RawAxiosRequestConfig,
    ) {
        return KycSubmissionApiFp(this.configuration)
            .kycSubmissionControllerKycSubmissionByUser(userId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Kyc submission count
     * @param {string} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycSubmissionApi
     */
    public kycSubmissionControllerKycSubmissionCount(
        status?: string,
        options?: RawAxiosRequestConfig,
    ) {
        return KycSubmissionApiFp(this.configuration)
            .kycSubmissionControllerKycSubmissionCount(status, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Paginated kyc submissions
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycSubmissionApi
     */
    public kycSubmissionControllerPaginatedKycSubmissions(
        page?: number,
        limit?: number,
        options?: RawAxiosRequestConfig,
    ) {
        return KycSubmissionApiFp(this.configuration)
            .kycSubmissionControllerPaginatedKycSubmissions(
                page,
                limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Reject submission
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycSubmissionApi
     */
    public kycSubmissionControllerRejectSubmission(
        id: string,
        options?: RawAxiosRequestConfig,
    ) {
        return KycSubmissionApiFp(this.configuration)
            .kycSubmissionControllerRejectSubmission(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const KycSubmissionControllerCreateKycSubmissionGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
} as const;
export type KycSubmissionControllerCreateKycSubmissionGenderEnum =
    (typeof KycSubmissionControllerCreateKycSubmissionGenderEnum)[keyof typeof KycSubmissionControllerCreateKycSubmissionGenderEnum];

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
    configuration?: Configuration,
) {
    return {
        /**
         *
         * @summary Paginated users
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerPaginatedUsers: async (
            page?: number,
            limit?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Users count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUsersCount: async (
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Paginated users
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerPaginatedUsers(
            page?: number,
            limit?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<PaginatedUserResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.userControllerPaginatedUsers(
                    page,
                    limit,
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['UserApi.userControllerPaginatedUsers']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Users count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUsersCount(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<TotalUserCountResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.userControllerUsersCount(
                    options,
                );
            const localVarOperationServerIndex =
                configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['UserApi.userControllerUsersCount']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         *
         * @summary Paginated users
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerPaginatedUsers(
            page?: number,
            limit?: number,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedUserResponse> {
            return localVarFp
                .userControllerPaginatedUsers(page, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Users count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUsersCount(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<TotalUserCountResponse> {
            return localVarFp
                .userControllerUsersCount(options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @summary Paginated users
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerPaginatedUsers(
        page?: number,
        limit?: number,
        options?: RawAxiosRequestConfig,
    ) {
        return UserApiFp(this.configuration)
            .userControllerPaginatedUsers(page, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Users count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerUsersCount(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration)
            .userControllerUsersCount(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
